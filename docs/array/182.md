# æŸ¥æ‰¾ä½¿æ•°ç»„å›æ–‡çš„æœ€å°åˆå¹¶æ“ä½œæ•°

> åŸæ–‡ï¼š [https://www.geeksforgeeks.org/find-minimum-number-of-merge-operations-to-make-an-array-palindrome/](https://www.geeksforgeeks.org/find-minimum-number-of-merge-operations-to-make-an-array-palindrome/)

ç»™å®šä¸€ä¸ªæ­£æ•´æ•°æ•°ç»„ã€‚ æˆ‘ä»¬éœ€è¦å°†ç»™å®šçš„æ•°ç»„è®¾ä¸ºâ€œå›æ–‡â€ã€‚ ä»…å…è®¸å¯¹æ•°ç»„è¿›è¡Œçš„æ“ä½œæ˜¯åˆå¹¶ã€‚ åˆå¹¶ä¸¤ä¸ªç›¸é‚»å…ƒç´ æ„å‘³ç€ç”¨å®ƒä»¬çš„æ€»å’Œæ›¿æ¢å®ƒä»¬ã€‚ ä»»åŠ¡æ˜¯æ‰¾åˆ°ä½¿ç»™å®šæ•°ç»„æˆä¸ºâ€œå›æ–‡â€æ‰€éœ€çš„æœ€å°åˆå¹¶æ“ä½œæ•°ã€‚

ä¸ºäº†ä½¿æ•°ç»„æˆä¸ºå›æ–‡ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å°†åˆå¹¶æ“ä½œåº”ç”¨ n-1 æ¬¡ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„å¤§å°ï¼ˆè¯·æ³¨æ„ï¼Œå•ä¸ªå…ƒç´ æ•°ç»„æ€»æ˜¯å›æ–‡ï¼Œç±»ä¼¼äºå•ä¸ªå­—ç¬¦ä¸²ï¼‰ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ•°ç»„çš„å¤§å°å°†å‡å°ä¸º 1ã€‚ä½†æ˜¯åœ¨è¿™ä¸ªé—®é¢˜ä¸Šï¼Œæˆ‘ä»¬è¢«è¦æ±‚ä»¥æœ€å°‘çš„æ“ä½œæ•°æ¥å®Œæˆã€‚

**ç¤ºä¾‹**ï¼š

```
Input : arr[] = {15, 4, 15}
Output : 0
Array is already a palindrome. So we
do not need any merge operation.

Input : arr[] = {1, 4, 5, 1}
Output : 1
We can make given array palindrome with
minimum one merging (merging 4 and 5 to
make 9)

Input : arr[] = {11, 14, 15, 99}
Output : 3
We need to merge all elements to make
a palindrome.

```

é¢„æœŸæ—¶é—´å¤æ‚åº¦ä¸º Oï¼ˆnï¼‰ã€‚

[](https://practice.geeksforgeeks.org/problem-page.php?pid=670)

## å¼ºçƒˆå»ºè®®æ‚¨åœ¨ç»§ç»­è§£å†³æ–¹æ¡ˆä¹‹å‰ï¼Œå•å‡»æ­¤å¤„è¿›è¡Œç»ƒä¹ ã€‚

ä»¤ fï¼ˆiï¼Œjï¼‰ä¸ºä½¿å­æ•°ç»„ arr [i..j]æˆä¸ºå›æ–‡å¼çš„æœ€å°åˆå¹¶æ“ä½œã€‚ å¦‚æœ i == jï¼Œç­”æ¡ˆä¸º 0ã€‚æˆ‘ä»¬ä» 0 å¼€å§‹ï¼Œè€Œ i ä» n-1 å¼€å§‹ã€‚

1.  å¦‚æœ arr [i] == arr [j]ï¼Œåˆ™æ— éœ€å¯¹ç´¢å¼• i æˆ–ç´¢å¼• j è¿›è¡Œä»»ä½•åˆå¹¶æ“ä½œã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„ç­”æ¡ˆå°†æ˜¯ fï¼ˆi + 1ï¼Œj-1ï¼‰ã€‚
2.  å¦åˆ™ï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œåˆå¹¶æ“ä½œã€‚ å‡ºç°ä»¥ä¸‹æƒ…å†µã€‚

*   å¦‚æœ arr [i] > arr [j]ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”è¯¥åœ¨ç´¢å¼• j å¤„è¿›è¡Œåˆå¹¶æ“ä½œã€‚ æˆ‘ä»¬åˆå¹¶ç´¢å¼• j-1 å’Œ jï¼Œå¹¶æ›´æ–° arr [j-1] = arr [j-1] + arr [j]ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„ç­”æ¡ˆå°†æ˜¯ 1 + fï¼ˆiï¼Œj-1ï¼‰ã€‚
*   å¯¹äº arr [i] < arr [j]çš„æƒ…å†µï¼Œæ›´æ–° arr [i + 1] = arr [i + 1] + arr [i]ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„ç­”æ¡ˆå°†æ˜¯ 1 + fï¼ˆi + 1ï¼Œjï¼‰ã€‚

*   æˆ‘ä»¬çš„ç­”æ¡ˆå°†æ˜¯ fï¼ˆ0ï¼Œn-1ï¼‰ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„ arr []çš„å¤§å°ã€‚

å› æ­¤ï¼Œå¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼ˆç¬¬ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æ•°ç»„çš„å¼€å§‹ï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆæŒ‡å‘æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼‰æ–¹æ³•è¿­ä»£åœ°è§£å†³æ­¤é—®é¢˜ï¼Œå¹¶ä¿æŒåˆ°ç›®å‰ä¸ºæ­¢å®Œæˆçš„åˆå¹¶æ“ä½œæ€»æ•°ã€‚

ä»¥ä¸‹æ˜¯ä¸Šè¿°æƒ³æ³•çš„å®ç°ã€‚

## C

```

// C++ program to find number of operations 
// to make an array palindrome 
#include <bits/stdc++.h> 
using namespace std; 

// Returns minimum number of count operations 
// required to make arr[] palindrome 
int findMinOps(int arr[], int n) 
{ 
Â Â Â Â int ans = 0; // Initialize result 

Â Â Â Â // Start from two corners 
Â Â Â Â for (int i=0,j=n-1; i<=j;) 
Â Â Â Â { 
Â Â Â Â Â Â Â Â // If corner elements are same, 
Â Â Â Â Â Â Â Â // problem reduces arr[i+1..j-1] 
Â Â Â Â Â Â Â Â if (arr[i] == arr[j]) 
Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â i++; 
Â Â Â Â Â Â Â Â Â Â Â Â j--; 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â // If left element is greater, then 
Â Â Â Â Â Â Â Â // we merge right two elements 
Â Â Â Â Â Â Â Â else if (arr[i] > arr[j]) 
Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â // need to merge from tail. 
Â Â Â Â Â Â Â Â Â Â Â Â j--; 
Â Â Â Â Â Â Â Â Â Â Â Â arr[j] += arr[j+1] ; 
Â Â Â Â Â Â Â Â Â Â Â Â ans++; 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â // Else we merge left two elements 
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â i++; 
Â Â Â Â Â Â Â Â Â Â Â Â arr[i] += arr[i-1]; 
Â Â Â Â Â Â Â Â Â Â Â Â ans++; 
Â Â Â Â Â Â Â Â } 
Â Â Â Â } 

Â Â Â Â return ans; 
} 

// Driver program to test above 
int main() 
{ 
Â Â Â Â int arr[] = {1, 4, 5, 9, 1}; 
Â Â Â Â int n = sizeof(arr)/sizeof(arr[0]); 
Â Â Â Â cout << "Count of minimum operations is "
Â Â Â Â Â Â Â Â Â <<Â  findMinOps(arr, n) << endl; 
Â Â Â Â return 0; 
} 

```

## Java

```

// Java program to find number of operations 
// to make an array palindrome 

class GFG 
{ 
Â Â Â Â // Returns minimum number of count operations 
Â Â Â Â // required to make arr[] palindrome 
Â Â Â Â static int findMinOps(int[] arr, int n) 
Â Â Â Â { 
Â Â Â Â Â Â Â Â int ans = 0; // Initialize result 

Â Â Â Â Â Â Â Â // Start from two corners 
Â Â Â Â Â Â Â Â for (int i=0,j=n-1; i<=j;) 
Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â // If corner elements are same, 
Â Â Â Â Â Â Â Â Â Â Â Â // problem reduces arr[i+1..j-1] 
Â Â Â Â Â Â Â Â Â Â Â Â if (arr[i] == arr[j]) 
Â Â Â Â Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â i++; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â j--; 
Â Â Â Â Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â Â Â Â Â // If left element is greater, then 
Â Â Â Â Â Â Â Â Â Â Â Â // we merge right two elements 
Â Â Â Â Â Â Â Â Â Â Â Â else if (arr[i] > arr[j]) 
Â Â Â Â Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // need to merge from tail. 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â j--; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â arr[j] += arr[j+1] ; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ans++; 
Â Â Â Â Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â Â Â Â Â // Else we merge left two elements 
Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â i++; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â arr[i] += arr[i-1]; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ans++; 
Â Â Â Â Â Â Â Â Â Â Â Â } 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â return ans; 
Â Â Â Â } 

Â Â Â Â // Driver method to test the above function 
Â Â Â Â public static void main(String[] args) 
Â Â Â Â { 
Â Â Â Â Â Â Â Â int arr[] = new int[]{1, 4, 5, 9, 1} ; 
Â Â Â Â Â Â Â Â System.out.println("Count of minimum operations is "+ 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â findMinOps(arr, arr.length)); 

Â Â Â Â } 
} 

```

## Python

```

# Python program to find number of operations 
# to make an array palindrome 

# Returns minimum number of count operations 
# required to make arr[] palindrome 
def findMinOps(arr, n): 
Â Â Â Â ans = 0 # Initialize result 

Â Â Â Â # Start from two corners 
Â Â Â Â i,j = 0,n-1
Â Â Â Â while i<=j: 
Â Â Â Â Â Â Â Â # If corner elements are same, 
Â Â Â Â Â Â Â Â # problem reduces arr[i+1..j-1] 
Â Â Â Â Â Â Â Â if arr[i] == arr[j]: 
Â Â Â Â Â Â Â Â Â Â Â Â i += 1
Â Â Â Â Â Â Â Â Â Â Â Â j -= 1

Â Â Â Â Â Â Â Â # If left element is greater, then 
Â Â Â Â Â Â Â Â # we merge right two elements 
Â Â Â Â Â Â Â Â elif arr[i] > arr[j]: 
Â Â Â Â Â Â Â Â Â Â Â Â # need to merge from tail. 
Â Â Â Â Â Â Â Â Â Â Â Â j -= 1
Â Â Â Â Â Â Â Â Â Â Â Â arr[j] += arr[j+1]Â  
Â Â Â Â Â Â Â Â Â Â Â Â ans += 1

Â Â Â Â Â Â Â Â # Else we merge left two elements 
Â Â Â Â Â Â Â Â else: 
Â Â Â Â Â Â Â Â Â Â Â Â i += 1
Â Â Â Â Â Â Â Â Â Â Â Â arr[i] += arr[i-1] 
Â Â Â Â Â Â Â Â Â Â Â Â ans += 1

Â Â Â Â return ans 

# Driver program to test above 
arr = [1, 4, 5, 9, 1] 
n = len(arr) 
print("Count of minimum operations is " + str(findMinOps(arr, n))) 

# This code is contributed by Pratik Chhajer 

```

## C# 

```

// C# program to find number of operations 
// to make an array palindrome 
using System; 

class GFG 
{ 
Â Â Â Â // Returns minimum number of count operations 
Â Â Â Â // required to make arr[] palindrome 
Â Â Â Â static int findMinOps(int []arr, int n) 
Â Â Â Â { 
Â Â Â Â Â Â Â Â int ans = 0; // Initialize result 

Â Â Â Â Â Â Â Â // Start from two corners 
Â Â Â Â Â Â Â Â for (int i = 0, j = n - 1; i <= j;) 
Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â // If corner elements are same, 
Â Â Â Â Â Â Â Â Â Â Â Â // problem reduces arr[i+1..j-1] 
Â Â Â Â Â Â Â Â Â Â Â Â if (arr[i] == arr[j]) 
Â Â Â Â Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â i++; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â j--; 
Â Â Â Â Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â Â Â Â Â // If left element is greater, then 
Â Â Â Â Â Â Â Â Â Â Â Â // we merge right two elements 
Â Â Â Â Â Â Â Â Â Â Â Â else if (arr[i] > arr[j]) 
Â Â Â Â Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // need to merge from tail. 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â j--; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â arr[j] += arr[j + 1] ; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ans++; 
Â Â Â Â Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â Â Â Â Â // Else we merge left two elements 
Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â i++; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â arr[i] += arr[i-1]; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ans++; 
Â Â Â Â Â Â Â Â Â Â Â Â } 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â return ans; 
Â Â Â Â } 

Â Â Â Â // Driver Code 
Â Â Â Â public static void Main() 
Â Â Â Â { 
Â Â Â Â Â Â Â Â int []arr = new int[]{1, 4, 5, 9, 1} ; 
Â Â Â Â Â Â Â Â Console.Write("Count of minimum operations is " + 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â findMinOps(arr, arr.Length)); 

Â Â Â Â } 
} 

// This code is contributed by nitin mittal 

```

## PHP

```

<?php 
// PHP program to find numberÂ  
// of operations to make anÂ  
// array palindrome 

// Returns minimum number ofÂ  
// count operations required 
// to make arr[] palindrome 
function findMinOps($arr, $n) 
{ 
Â Â Â Â // Initialize result 
Â Â Â Â $ans = 1;Â  

Â Â Â Â // Start from two corners 
Â Â Â Â for ($i = 0, $j = $n - 1; $i <= $jğŸ˜‰ 
Â Â Â Â { 
Â Â Â Â Â Â Â Â // If corner elements are same, 
Â Â Â Â Â Â Â Â // problem reduces arr[i+1..j-1] 
Â Â Â Â Â Â Â Â if ($arr[$i] == $arr[$j]) 
Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â $i++; 
Â Â Â Â Â Â Â Â Â Â Â Â $j--; 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â // If left element is greater, then 
Â Â Â Â Â Â Â Â // we merge right two elements 
Â Â Â Â Â Â Â Â else if ($arr[$i] > $arr[$j]) 
Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â // need to merge from tail. 
Â Â Â Â Â Â Â Â Â Â Â Â $j--; 
Â Â Â Â Â Â Â Â Â Â Â Â $arr[$j] += $arr[$j + 1] ; 
Â Â Â Â Â Â Â Â Â Â Â Â $ans++; 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â // Else we mergeÂ  
Â Â Â Â Â Â Â Â // left two elements 
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â $i++; 
Â Â Â Â Â Â Â Â Â Â Â Â $arr[$i] += $arr[$i - 1]; 
Â Â Â Â Â Â Â Â Â Â Â Â $ans++; 
Â Â Â Â Â Â Â Â } 
Â Â Â Â } 

Â Â Â Â return $ans; 
} 

// Driver Code 
$arr[] = array(1, 4, 5, 9, 1); 
$n = sizeof($arr); 
echo "Count of minimum operations is ",Â  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â findMinOps($arr, $n) ; 

// This code is contributed by nitin mittal. 
?> 

```

**Output :**

```
Count of minimum operations is 1
```

ç»™å®šç¨‹åºçš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼šOï¼ˆnï¼‰

æœ¬æ–‡ç”± **Ashish Jain** æä¾›ã€‚ å¦‚æœæ‚¨å–œæ¬¢ GeeksforGeeks å¹¶å¸Œæœ›åšå‡ºè´¡çŒ®ï¼Œé‚£ä¹ˆæ‚¨ä¹Ÿå¯ä»¥å†™ä¸€ç¯‡æ–‡ç« ï¼Œå¹¶å°†æ‚¨çš„æ–‡ç« é‚®å¯„åˆ° contribution@geeksforgeeks.orgã€‚ æŸ¥çœ‹æ‚¨çš„æ–‡ç« å‡ºç°åœ¨ GeeksforGeeks ä¸»é¡µä¸Šï¼Œå¹¶å¸®åŠ©å…¶ä»– Geeksã€‚

å¦‚æœå‘ç°ä»»ä½•ä¸æ­£ç¡®çš„åœ°æ–¹ï¼Œæˆ–è€…æƒ³åˆ†äº«æœ‰å…³ä¸Šè¿°ä¸»é¢˜çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‘è¡¨è¯„è®ºã€‚

