# 执行加减命令后打印修改后的数组

> 原文： [https://www.geeksforgeeks.org/print-modified-array-executing-commands-addition-subtraction/](https://www.geeksforgeeks.org/print-modified-array-executing-commands-addition-subtraction/)

给定大小为'n'的数组和给定的大小为'm'的命令集。 每个命令由四个整数 q，l，r，k 组成。 这些命令具有以下类型：

*   如果 q = 0，则将'k'添加到范围'a'至'b'的所有整数中（1 < = a < = b < = n）。
*   如果 q = 1，则将'a'到'b'范围内的所有整数减去'k'（1 < = a < = b < = n）。

**注意**：最初，所有数组元素都设置为“ 0”，而数组索引从“ 1”开始。

```
Input : n = 5
        commands[] = {{0 1 3 2}, {1 3 5 3}, 
                      {0 2 5 1}}
Output : 0 2 -1 -1 -3
Explanation
First command: Add 2 from index 1 to 3
>=  2 2 2 0 0
Second command: Subtract 3 from index 3 to 5 
>= 2 2 -1 -3 -3
Third command: Add 1 from index 2 to 5
>= 2 3 0 -2 -2

```



**简单方法**是通过从左索引（l）到右索引（r）进行迭代来执行每个命令，并根据给定命令更新每个索引。 该方法的时间复杂度为 O（n * m）

**更好的方法**是使用分域树（BIT）或段树。 但这只会最优化 log（n）时间，即整体复杂度将变为 O（m * log（n））

**高效方法**是使用简单的数学方法。 由于所有命令都可以脱机处理，因此我们可以将所有更新存储在临时数组中，然后最后执行它。

*   对于命令“ **0** ”，在 **l <sup>th</sup>** 中添加“ **+ k** ”和“ **-k** ”。 **（r + 1）个<sup>第</sup>** 个索引元素。
*   对于命令“ **1** ”，在 **l <sup>th</sup>** 中添加“ **-k** ”和“ **+ k** ”。 和**（r + 1）<sup>第</sup>** 个索引元素。

之后，对每个索引' **i** '的所有元素求和，从 1 <sup>st</sup> 索引开始，即 **a <sub>i</sub>** 将包含总和 从 1 到第<sup>索引的所有元素的索引。 这可以通过动态编程轻松实现。</sup> 

## C++ 

```cpp

// C++ program to find modified array 
// after executing m commands/queries 
#include<bits/stdc++.h> 
using namespace std; 

// Update function for every command 
void updateQuery(int arr[], int n, int q, int l, 
                 int r, int k) 
{ 
    // If q == 0, add 'k' and '-k' 
    // to 'l-1' and 'r' index 
    if (q == 0){ 
        arr[l-1] += k; 
        arr[r] += -k; 
    } 

    // If q == 1, add '-k' and 'k' 
    // to 'l-1' and 'r' index 
    else{ 
        arr[l-1] += -k; 
        arr[r] += k; 
    } 
    return; 
} 

// Function to generate the final 
// array after executing all  
// commands 
void generateArray(int arr[], int n) 
{ 
    // Generate final array with the  
    // help of DP concept 
    for (int i = 1; i < n; ++i) 
        arr[i] += arr[i-1]; 

    return; 
} 

// Driver program 
int main() 
{ 
    int n = 5; 
    int arr[n+1]; 
    //Set all array elements to '0' 
    memset(arr, 0, sizeof(arr)); 

    int q = 0, l = 1, r = 3, k = 2; 
    updateQuery(arr, n, q, l, r, k); 

    q = 1 , l = 3, r = 5, k = 3; 
    updateQuery(arr, n, q, l, r, k); 

    q = 0 , l = 2, r = 5, k = 1; 
    updateQuery(arr, n, q, l, r, k); 

    // Generate final array 
    generateArray(arr, n); 

    // Printing the final modified array 
    for (int i = 0; i < n; ++i) 
        cout << arr[i] << " "; 
    return 0; 
} 

```