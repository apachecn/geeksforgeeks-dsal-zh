# æœ€é•¿é€’å¢å­åºåˆ—å¤§å°ï¼ˆN log Nï¼‰

> åŸæ–‡ï¼š [https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/](https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/)

ç»™å®šä¸€ä¸ªéšæœºæ•°æ•°ç»„ã€‚ åœ¨æ•°ç»„ä¸­æ‰¾åˆ°*å¢é•¿æœ€é•¿çš„[å­åºåˆ—](http://en.wikipedia.org/wiki/Substring)* ï¼ˆLISï¼‰ã€‚ æˆ‘çŸ¥é“ä½ ä»¬ä¸­è®¸å¤šäººå¯èƒ½å·²ç»é˜…è¯»[é€’å½’å’ŒåŠ¨æ€ç¼–ç¨‹](https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/)ï¼ˆDPï¼‰è§£å†³æ–¹æ¡ˆã€‚ è®ºå›å¸–å­ä¸­å¾ˆå°‘æœ‰äººè¦æ±‚ [Oï¼ˆN log Nï¼‰](http://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms)ç®—æ³•ã€‚

> [æ¨èï¼šè¯·å…ˆåœ¨â€œ ***å®è·µ*** â€ä¸Šè§£å†³å®ƒï¼Œç„¶åå†ç»§ç»­è§£å†³ã€‚](https://practice.geeksforgeeks.org/problems/longest-increasing-subsequence/0)

æš‚æ—¶ï¼Œæ— éœ€è€ƒè™‘é€’å½’å’Œ DP è§£å†³æ–¹æ¡ˆã€‚ è®©æˆ‘ä»¬æŠ½å–å°‘é‡æ ·æœ¬å¹¶å°†è§£å†³æ–¹æ¡ˆæ‰©å±•åˆ°å¤§å‹å®ä¾‹ã€‚ å°½ç®¡ä¹ä¸€çœ‹å¯èƒ½å¾ˆå¤æ‚ï¼Œä½†æ˜¯ä¸€æ—¦æˆ‘ä»¬ç†è§£äº†é€»è¾‘ï¼Œç¼–ç å°±å¾ˆç®€å•ã€‚

è€ƒè™‘è¾“å…¥æ•°ç»„ A = {2ï¼Œ5ï¼Œ3}ã€‚ æˆ‘å°†åœ¨è§£é‡Šè¿‡ç¨‹ä¸­æ‰©å±•æ•°ç»„ã€‚

é€šè¿‡è§‚å¯Ÿï¼Œæˆ‘ä»¬çŸ¥é“ LIS æ˜¯{2ï¼Œ3}æˆ–{2ï¼Œ5}ã€‚ ***è¯·æ³¨æ„ï¼Œæˆ‘ä»…è€ƒè™‘ä¸¥æ ¼å¢åŠ çš„åºåˆ—*** ã€‚

è®©æˆ‘ä»¬å†æ·»åŠ ä¸¤ä¸ªå…ƒç´ ï¼Œä¾‹å¦‚ 7ã€11ã€‚ è¿™äº›å…ƒç´ å°†æ‰©å±•ç°æœ‰åºåˆ—ã€‚ ç°åœ¨ï¼Œè¾“å…¥æ•°ç»„{2ï¼Œ5ï¼Œ3ï¼Œ7ï¼Œ11}çš„é€’å¢åºåˆ—ä¸º{2ï¼Œ3ï¼Œ7ï¼Œ11}å’Œ{2ï¼Œ5ï¼Œ7ï¼Œ11}ã€‚

æ­¤å¤–ï¼Œæˆ‘ä»¬åœ¨æ•°ç»„ä¸­å†æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œä¾‹å¦‚ 8ï¼Œå³è¾“å…¥æ•°ç»„å˜ä¸º{2ï¼Œ5ï¼Œ3ï¼Œ7ï¼Œ11ï¼Œ11}ã€‚ è¯·æ³¨æ„ï¼Œæœ€æ–°å…ƒç´  8 å¤§äºä»»ä½•æ´»åŠ¨åºåˆ—çš„æœ€å°å…ƒç´ ï¼ˆ*å°†ç®€çŸ­è®¨è®ºæ´»åŠ¨åºåˆ—*ï¼‰ã€‚ å¦‚ä½•å°†ç°æœ‰åºåˆ—æ‰©å±•ä¸º 8ï¼Ÿ é¦–å…ˆï¼Œ8 å¯ä»¥æˆä¸º LIS çš„ä¸€éƒ¨åˆ†å—ï¼Ÿ å¦‚æœæ˜¯ï¼Œæ€ä¹ˆåŠï¼Ÿ å¦‚æœæˆ‘ä»¬è¦æ·»åŠ  8ï¼Œå®ƒåº”è¯¥åœ¨ 7 ä¹‹åï¼ˆé€šè¿‡æ›¿æ¢ 11ï¼‰ã€‚

ç”±äºæ­¤æ–¹æ³•æ˜¯*è„±æœºï¼ˆæˆ‘ä»¬çš„æ„æ€æ˜¯[è„±æœº](https://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/)å—ï¼Ÿï¼‰*ï¼Œå› æ­¤æˆ‘ä»¬ä¸ç¡®å®šæ˜¯å¦æ·»åŠ  8 å°†æ‰©å±•è¯¥ç³»åˆ—ã€‚ å‡è®¾è¾“å…¥æ•°ç»„ä¸­æœ‰ 9 ä¸ªï¼Œä¾‹å¦‚{2ï¼Œ5ï¼Œ3ï¼Œ7ï¼Œ11ï¼Œ11ï¼Œ8ï¼Œ7ï¼Œ9â€¦}ã€‚ æˆ‘ä»¬å¯ä»¥å°† 8 æ›¿æ¢ä¸º 11ï¼Œå› ä¸ºå¯èƒ½å­˜åœ¨*æœ€ä½³*å€™é€‰ï¼ˆ9ï¼‰ï¼Œå¯ä»¥æ‰©å±•æ–°ç³»åˆ—{2ï¼Œ3ï¼Œ7ï¼Œ8}æˆ–{2ï¼Œ5ï¼Œ7ï¼Œ8}ã€‚

æˆ‘ä»¬çš„è§‚å¯Ÿç»“æœæ˜¯ï¼Œå‡è®¾æœ€å¤§åºåˆ—çš„ç»“å°¾å…ƒç´ ä¸º Eã€‚å¦‚æœå­˜åœ¨å…ƒç´  A [j]ï¼ˆj > iï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æœ‰åºåˆ—ä¸­æ·»åŠ ï¼ˆæ›¿æ¢ï¼‰å½“å‰å…ƒç´  A [i] < A [i] < A [j]æˆ–ï¼ˆ[E > A [i] < A [j] â€“ç”¨äºæ›¿æ¢ï¼‰ã€‚ åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼ŒE = 11ï¼ŒA [i] = 8ï¼ŒA [j] = 9ã€‚

å¯¹äºåŸå§‹æ•°ç»„{2ï¼Œ5ï¼Œ3}ï¼Œè¯·æ³¨æ„ï¼Œå½“æˆ‘ä»¬å°† 3 æ·»åŠ åˆ°é€’å¢åºåˆ—{2ï¼Œ5}æ—¶ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°ç›¸åŒçš„æƒ…å†µã€‚ æˆ‘åªæ˜¯åˆ›å»ºäº†ä¸¤ä¸ªé€’å¢çš„åºåˆ—ï¼Œä»¥ä½¿è¯´æ˜å˜å¾—ç®€å•ã€‚ 3 å¯ä»¥ä»£æ›¿åºåˆ—{2ï¼Œ5}ä¸­çš„ 5ï¼Œè€Œä¸æ˜¯ä¸¤ä¸ªåºåˆ—ã€‚

æˆ‘çŸ¥é“è¿™ä¼šä»¤äººå›°æƒ‘ï¼Œæˆ‘ä¼šå°½å¿«æ¸…é™¤å®ƒï¼

*é—®é¢˜æ˜¯ï¼Œä»€ä¹ˆæ—¶å€™å¯ä»¥å®‰å…¨åœ°æ·»åŠ æˆ–æ›¿æ¢ç°æœ‰åºåˆ—ä¸­çš„å…ƒç´ ï¼Ÿ*

è®©æˆ‘ä»¬è€ƒè™‘å¦ä¸€ä¸ªæ ·æœ¬ A = {2ï¼Œ5ï¼Œ3}ã€‚ å‡è®¾ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯ 1ã€‚å¦‚ä½•æ‰©å±•å½“å‰åºåˆ—{2ï¼Œ3}æˆ–{2ï¼Œ5}ã€‚ æ˜¾ç„¶ï¼Œå®ƒä¹Ÿä¸èƒ½æ‰©å±•ã€‚ ä½†æ˜¯ï¼Œæ–°çš„æœ€å°å…ƒç´ æœ‰å¯èƒ½æˆä¸º LIS çš„å¼€å§‹ã€‚ ä¸ºäº†æ¸…æ¥šèµ·è§ï¼Œè¯·è€ƒè™‘æ•°ç»„ä¸º{2ï¼Œ5ï¼Œ3ï¼Œ1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ6}ã€‚ å°† 1 è®¾ä¸ºæ–°åºåˆ—å°†åˆ›å»ºæœ€å¤§çš„æ–°åºåˆ—ã€‚

*è§‚å¯Ÿç»“æœæ˜¯ï¼Œå½“æˆ‘ä»¬é‡åˆ°æ•°ç»„ä¸­çš„æ–°æœ€å°å…ƒç´ æ—¶ï¼Œå®ƒå¯èƒ½æ˜¯å¼€å§‹æ–°åºåˆ—çš„æ½œåœ¨å€™é€‰è€…ã€‚*

ä»è§‚å¯Ÿä¸­ï¼Œæˆ‘ä»¬éœ€è¦ç»´æŠ¤é€’å¢åºåˆ—çš„åˆ—è¡¨ã€‚

æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬æœ‰ä¸€ç»„**æ´»åŠ¨åˆ—è¡¨**ä¸åŒé•¿åº¦ã€‚ æˆ‘ä»¬å°†å…ƒç´  A [i]æ·»åŠ åˆ°è¿™äº›åˆ—è¡¨ä¸­ã€‚ æˆ‘ä»¬ä»¥é•¿åº¦å‡å°‘çš„é¡ºåºæ‰«æåˆ—è¡¨ï¼ˆç”¨äºç»“æŸå…ƒç´ ï¼‰ã€‚ æˆ‘ä»¬å°†éªŒè¯æ‰€æœ‰åˆ—è¡¨çš„æœ«ç«¯å…ƒç´ ï¼Œä»¥æ‰¾åˆ°ä¸€ä¸ªæœ«ç«¯å…ƒç´ å°äº A [i]ï¼ˆ*ä¸‹é™*å€¼ï¼‰çš„åˆ—è¡¨ã€‚

æˆ‘ä»¬çš„ç­–ç•¥ç”±ä»¥ä¸‹æ¡ä»¶å†³å®šï¼Œ

```
1\. If A[i] is smallest among all *end* 
   candidates of active lists, we will *start* 
   new active list of length 1.
```

```
2\. If A[i] is largest among all *end* candidates of 
  active lists, we will clone the *largest* active 
  list, and extend it by A[i].
```

```
 3\. If A[i] is in between, we will find a list with 
  *largest end element that is smaller than* A[i]. 
  Clone and extend this list by A[i]. We will discard all
  other lists of same length as that of this modified list.
```

è¯·æ³¨æ„ï¼Œåœ¨æ„é€ æ´»åŠ¨åˆ—è¡¨çš„ä»»ä½•æ—¶å€™ï¼Œéƒ½å°†ä¿æŒä»¥ä¸‹æ¡ä»¶ã€‚

*â€œè¾ƒå°åˆ—è¡¨çš„æœ«å°¾å…ƒç´ å°äºè¾ƒå¤§åˆ—è¡¨çš„æœ«å°¾å…ƒç´ â€* ã€‚

ä¸¾ä¸€ä¸ªä¾‹å­å¾ˆæ˜æ˜¾ï¼Œè®©æˆ‘ä»¬ä»¥ [Wiki](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) {0ï¼Œ8ï¼Œ4ï¼Œ12ï¼Œ2ï¼Œ10ï¼Œ6ï¼Œ14ï¼Œ1ï¼Œ1ï¼Œ9ï¼Œ5ï¼Œ13ï¼Œ13ï¼Œ3ï¼Œ11ï¼Œ7 ï¼Œ15}ã€‚

```
A[0] = 0\. Case 1\. There are no active lists, create one.
0.
-----------------------------------------------------------------------------
A[1] = 8\. Case 2\. Clone and extend.
0.
0, 8.
-----------------------------------------------------------------------------
A[2] = 4\. Case 3\. Clone, extend and discard.
0.
0, 4.
0, 8. Discarded
-----------------------------------------------------------------------------
A[3] = 12\. Case 2\. Clone and extend.
0.
0, 4.
0, 4, 12.
-----------------------------------------------------------------------------
A[4] = 2\. Case 3\. Clone, extend and discard.
0.
0, 2.
0, 4. Discarded.
0, 4, 12.
-----------------------------------------------------------------------------
A[5] = 10\. Case 3\. Clone, extend and discard.
0.
0, 2.
0, 2, 10.
0, 4, 12. Discarded.
-----------------------------------------------------------------------------
A[6] = 6\. Case 3\. Clone, extend and discard.
0.
0, 2.
0, 2, 6.
0, 2, 10. Discarded.
-----------------------------------------------------------------------------
A[7] = 14\. Case 2\. Clone and extend.
0.
0, 2.
0, 2, 6.
0, 2, 6, 14.
-----------------------------------------------------------------------------
A[8] = 1\. Case 3\. Clone, extend and discard.
0.
0, 1.
0, 2. Discarded.
0, 2, 6.
0, 2, 6, 14.
-----------------------------------------------------------------------------
A[9] = 9\. Case 3\. Clone, extend and discard.
0.
0, 1.
0, 2, 6.
0, 2, 6, 9.
0, 2, 6, 14. Discarded.
-----------------------------------------------------------------------------
A[10] = 5\. Case 3\. Clone, extend and discard.
0.
0, 1.
0, 1, 5.
0, 2, 6. Discarded.
0, 2, 6, 9.
-----------------------------------------------------------------------------
A[11] = 13\. Case 2\. Clone and extend.
0.
0, 1.
0, 1, 5.
0, 2, 6, 9.
0, 2, 6, 9, 13.
-----------------------------------------------------------------------------
A[12] = 3\. Case 3\. Clone, extend and discard.
0.
0, 1.
0, 1, 3.
0, 1, 5. Discarded.
0, 2, 6, 9.
0, 2, 6, 9, 13.
-----------------------------------------------------------------------------
A[13] = 11\. Case 3\. Clone, extend and discard.
0.
0, 1.
0, 1, 3.
0, 2, 6, 9.
0, 2, 6, 9, 11.
0, 2, 6, 9, 13. Discarded.
-----------------------------------------------------------------------------
A[14] = 7\. Case 3\. Clone, extend and discard.
0.
0, 1.
0, 1, 3.
0, 1, 3, 7.
0, 2, 6, 9. Discarded.
0, 2, 6, 9, 11.
----------------------------------------------------------------------------
A[15] = 15\. Case 2\. Clone and extend.
0.
0, 1.
0, 1, 3.
0, 1, 3, 7.
0, 2, 6, 9, 11.
0, 2, 6, 9, 11, 15\. <-- LIS List
----------------------------------------------------------------------------
```

è®¾è®¡ç®—æ³•éœ€è¦äº†è§£ä»¥ä¸Šç­–ç•¥ã€‚ å¦å¤–ï¼Œç¡®ä¿æˆ‘ä»¬ä¿æŒä»¥ä¸‹æ¡ä»¶ï¼šâ€œè¾ƒå°åˆ—è¡¨çš„*ç»“æŸå…ƒç´ å°äºè¾ƒå¤§åˆ—è¡¨*çš„ç»“æŸå…ƒç´ â€ã€‚ åœ¨è¿›ä¸€æ­¥é˜…è¯»ä¹‹å‰ï¼Œè¯·å°è¯•å…¶ä»–ä¸€äº›ç¤ºä¾‹ã€‚ é‡è¦çš„æ˜¯è¦äº†è§£ç»“æŸå…ƒç´ å‘ç”Ÿäº†ä»€ä¹ˆã€‚

**ç®—æ³•**ï¼š

æŸ¥è¯¢æœ€é•¿çš„é•¿åº¦ç›¸å½“å®¹æ˜“ã€‚ è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä»…å¤„ç†æœ«ç«¯å…ƒç´ ã€‚ æˆ‘ä»¬ä¸éœ€è¦ç»´æŠ¤æ‰€æœ‰åˆ—è¡¨ã€‚ æˆ‘ä»¬å¯ä»¥å°†ç»“æŸå…ƒç´ å­˜å‚¨åœ¨æ•°ç»„ä¸­ã€‚ ä¸¢å¼ƒæ“ä½œå¯ä»¥é€šè¿‡æ›¿æ¢è¿›è¡Œæ¨¡æ‹Ÿï¼Œå¹¶ä¸”æ‰©å±•åˆ—è¡¨ç±»ä¼¼äºå‘æ•°ç»„æ·»åŠ æ›´å¤šå…ƒç´ ã€‚

æˆ‘ä»¬å°†ä½¿ç”¨è¾…åŠ©æ•°ç»„æ¥ä¿ç•™ç»“æŸå…ƒç´ ã€‚ è¯¥æ•°ç»„çš„æœ€å¤§é•¿åº¦æ˜¯è¾“å…¥çš„é•¿åº¦ã€‚ åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œæ•°ç»„ä¼šåˆ†æˆ N ä¸ªå¤§å°ä¸º 1 çš„åˆ—è¡¨ï¼ˆ*æ³¨æ„ï¼Œè¿™ä¸ä¼šå¯¼è‡´æœ€åæƒ…å†µä¸‹çš„å¤æ‚æ€§*ï¼‰ã€‚ è¦ä¸¢å¼ƒä¸€ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬å°†åœ¨è¾…åŠ©æ•°ç»„ä¸­è·Ÿè¸ª A [i]çš„ ceil å€¼ï¼ˆå†æ¬¡è§‚å¯Ÿæ‚¨çš„ç²—ç•¥å·¥ä½œä¸­çš„æœ«ç«¯å…ƒç´ ï¼‰ï¼Œå¹¶å°† ceil å€¼æ›¿æ¢ä¸º A [i]ã€‚ æˆ‘ä»¬é€šè¿‡å°†å…ƒç´ æ·»åŠ åˆ°è¾…åŠ©æ•°ç»„æ¥æ‰©å±•åˆ—è¡¨ã€‚ æˆ‘ä»¬è¿˜ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨æ¥è·Ÿè¸ªè¾…åŠ©æ•°ç»„çš„é•¿åº¦ã€‚

**Bonus:**Â You have learntÂ [Patience Sorting](http://en.wikipedia.org/wiki/Patience_sorting)Â technique partially ğŸ™‚

Here is a proverb, â€œ*Tell me and I will forget. Show me and I will remember. Involve me and I will understand*.â€ So, pick a suit from deck of cards. Find the longest increasing sub-sequence of cards from the shuffled suit. You will never forget the approach. ğŸ™‚

**æ›´æ–°â€“ 2016 å¹´ 7 æœˆ 17 æ—¥**ï¼šè¯»è€…ä»¬çš„å›å“é¢‡ä¸ºæ·±åˆ»ï¼Œå¾ˆå°‘æœ‰ç½‘ç«™å¼•ç”¨æ­¤å¸–å­ï¼Œæ„Ÿåˆ°å¾ˆé«˜å…´ï¼Œå› ä¸ºæˆ‘ä¸ºåˆ«äººæä¾›å¸®åŠ©è€Œæ„Ÿåˆ°è¾›è‹¦ã€‚ çœ‹æ¥è¯»è€…åœ¨å‘è¡¨è¯„è®ºä¹‹å‰æ²¡æœ‰åšä»»ä½•åŠŸè¯¾ã€‚ é˜…è¯»æœ¬æ–‡åè¦æ±‚é˜…è¯»ä¸€äº›ç¤ºä¾‹ï¼Œå¹¶è¯·åœ¨çº¸ä¸Šåšæ‚¨çš„å·¥ä½œï¼ˆè¯·å‹¿ä½¿ç”¨ç¼–è¾‘å™¨/ç¼–è¯‘å™¨ï¼‰ã€‚ è¦æ±‚æ˜¯å¸®åŠ©è‡ªå·±ã€‚ å¯¹``çŸ¥é“''çš„ä¸“ä¸šä¸åŒäºçœŸæ­£çš„ç†è§£ï¼ˆä¸å°Šé‡ï¼‰ã€‚ ä»¥ä¸‹æ˜¯æˆ‘çš„ä¸ªäººç»å†ã€‚

*æœ€åˆçš„å†…å®¹å‡†å¤‡å·¥ä½œå¤§çº¦èŠ±äº†æˆ‘ 6 ä¸ªå°æ—¶ã€‚ ä½†æ˜¯ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æ•™è®­ã€‚ æˆ‘åœ¨ä¸€ä¸ªå°æ—¶å†…å®Œæˆäº†åˆå§‹ä»£ç ã€‚ å½“æˆ‘å¼€å§‹å†™å†…å®¹å‘è¯»è€…è§£é‡Šæ—¶ï¼Œæˆ‘æ„è¯†åˆ°æˆ‘ä¸ç†è§£è¿™äº›æ¡ˆä¾‹ã€‚ æ‹¿äº†æˆ‘çš„ç¬”è®°æœ¬ï¼ˆæˆ‘ä¹ æƒ¯äºè£…è®¢ç»‘å®šçš„ç¬”è®°æœ¬ä»¥è·Ÿè¸ªæˆ‘çš„ç²—ç•¥å·¥ä½œï¼‰ï¼Œå‡ ä¸ªå°æ—¶åï¼Œæˆ‘å¡«å†™äº†å°†è¿‘ 15 é¡µçš„ç²—ç•¥å·¥ä½œã€‚ æ— è®ºæ‚¨åœ¨ç°è‰²ç¤ºä¾‹ä¸­çœ‹åˆ°çš„å†…å®¹æ˜¯æ¥è‡ªè¿™äº›é¡µé¢çš„ã€‚ æˆ‘å¼ºçƒˆå»ºè®®æ‚¨å®è·µã€Š Udi Manber ç®—æ³•å…¥é—¨ã€‹ä¸€ä¹¦ä¸­çš„æ³¨é‡Šè§¦å‘è§£å†³æ–¹æ¡ˆçš„æ‰€æœ‰æ€è€ƒè¿‡ç¨‹ã€‚*

æˆ‘æ€€ç–‘ï¼Œè®¸å¤šè¯»è€…å¯èƒ½æ— æ³•ç†è§£ CeilIndexï¼ˆäºŒåˆ†æœç´¢ï¼‰èƒŒåçš„é€»è¾‘ã€‚ æˆ‘æŠŠå®ƒä½œä¸ºç»ƒä¹ è®©è¯»è€…ç†è§£å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚ åœ¨çº¸ä¸Šæµè§ˆå‡ ä¸ªç¤ºä¾‹ã€‚ æˆ‘æ„è¯†åˆ°æˆ‘å·²ç»åœ¨[çš„å¦ä¸€ç¯‡æ–‡ç« ](https://www.geeksforgeeks.org/the-ubiquitous-binary-search-set-1/)ä¸­ä»‹ç»äº†è¯¥ç®—æ³•ã€‚

**æ›´æ–°â€“ 2016 å¹´ 8 æœˆ 5 æ—¥**ï¼š

å®Œæˆå·¥ä½œåï¼Œä»¥ä¸‹é“¾æ¥å€¼å¾—å‚è€ƒã€‚ æˆ‘é€šè¿‡æœ€è¿‘åˆ›å»ºçš„ **Disqus** ä¸ªäººèµ„æ–™è®¤è¯†äº†è¯¥é“¾æ¥ã€‚ è¯¥é“¾æ¥å…·æœ‰ Wiki ä¸­æåˆ°çš„æ–¹æ³•çš„è¯´æ˜ã€‚

[http://stackoverflow.com/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming](http://stackoverflow.com/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming)

ä¸‹é¢ç»™å‡ºçš„æ˜¯æŸ¥æ‰¾ LIS é•¿åº¦çš„ä»£ç ï¼ˆ*æ›´æ–°ä¸º C++  11 ä»£ç ï¼Œæ²¡æœ‰ C æ ·å¼çš„æ•°ç»„*ï¼‰ï¼Œ

## C++ 

```

#include <iostream> 
#include <vector> 

// Binary search (note boundaries in the caller) 
int CeilIndex(std::vector<int>& v, int l, int r, int key) 
{ 
Â Â Â Â while (r - l > 1) { 
Â Â Â Â Â Â Â Â int m = l + (r - l) / 2; 
Â Â Â Â Â Â Â Â if (v[m] >= key) 
Â Â Â Â Â Â Â Â Â Â Â Â r = m; 
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â l = m; 
Â Â Â Â } 

Â Â Â Â return r; 
} 

int LongestIncreasingSubsequenceLength(std::vector<int>& v) 
{ 
Â Â Â Â if (v.size() == 0) 
Â Â Â Â Â Â Â Â return 0; 

Â Â Â Â std::vector<int> tail(v.size(), 0); 
Â Â Â Â int length = 1; // always points empty slot in tail 

Â Â Â Â tail[0] = v[0]; 
Â Â Â Â for (size_t i = 1; i < v.size(); i++) { 

Â Â Â Â Â Â Â Â // new smallest value 
Â Â Â Â Â Â Â Â if (v[i] < tail[0]) 
Â Â Â Â Â Â Â Â Â Â Â Â tail[0] = v[i]; 

Â Â Â Â Â Â Â Â // v[i] extends largest subsequence 
Â Â Â Â Â Â Â Â else if (v[i] > tail[length - 1]) 
Â Â Â Â Â Â Â Â Â Â Â Â tail[length++] = v[i]; 

Â Â Â Â Â Â Â Â // v[i] will become end candidate of an existing 
Â Â Â Â Â Â Â Â // subsequence or Throw away larger elements in all 
Â Â Â Â Â Â Â Â // LIS, to make room for upcoming grater elements 
Â Â Â Â Â Â Â Â // than v[i] (and also, v[i] would have already 
Â Â Â Â Â Â Â Â // appeared in one of LIS, identify the location 
Â Â Â Â Â Â Â Â // and replace it) 
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â tail[CeilIndex(tail, -1, length - 1, v[i])] = v[i]; 
Â Â Â Â } 

Â Â Â Â return length; 
} 

int main() 
{ 
Â Â Â Â std::vector<int> v{ 2, 5, 3, 7, 11, 8, 10, 13, 6 }; 
Â Â Â Â std::cout << "Length of Longest Increasing Subsequence is "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â << LongestIncreasingSubsequenceLength(v) << '\n'; 
Â Â Â Â return 0; 
} 

```

## Java

```

// Java program to find length of longest increasing subsequence 
// in O(n Log n) time 
import java.io.*; 
import java.util.*; 
import java.lang.Math; 

class LIS { 
Â Â Â Â // Binary search (note boundaries in the caller) 
Â Â Â Â // A[] is ceilIndex in the caller 
Â Â Â Â static int CeilIndex(int A[], int l, int r, int key) 
Â Â Â Â { 
Â Â Â Â Â Â Â Â while (r - l > 1) { 
Â Â Â Â Â Â Â Â Â Â Â Â int m = l + (r - l) / 2; 
Â Â Â Â Â Â Â Â Â Â Â Â if (A[m] >= key) 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â r = m; 
Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â l = m; 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â return r; 
Â Â Â Â } 

Â Â Â Â static int LongestIncreasingSubsequenceLength(int A[], int size) 
Â Â Â Â { 
Â Â Â Â Â Â Â Â // Add boundary case, when array size is one 

Â Â Â Â Â Â Â Â int[] tailTable = new int[size]; 
Â Â Â Â Â Â Â Â int len; // always points empty slot 

Â Â Â Â Â Â Â Â tailTable[0] = A[0]; 
Â Â Â Â Â Â Â Â len = 1; 
Â Â Â Â Â Â Â Â for (int i = 1; i < size; i++) { 
Â Â Â Â Â Â Â Â Â Â Â Â if (A[i] < tailTable[0]) 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // new smallest value 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tailTable[0] = A[i]; 

Â Â Â Â Â Â Â Â Â Â Â Â else if (A[i] > tailTable[len - 1]) 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // A[i] wants to extend largest subsequence 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tailTable[len++] = A[i]; 

Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // A[i] wants to be current end candidate of an existing 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // subsequence. It will replace ceil value in tailTable 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]; 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â return len; 
Â Â Â Â } 

Â Â Â Â // Driver program to test above function 
Â Â Â Â public static void main(String[] args) 
Â Â Â Â { 
Â Â Â Â Â Â Â Â int A[] = { 2, 5, 3, 7, 11, 8, 10, 13, 6 }; 
Â Â Â Â Â Â Â Â int n = A.length; 
Â Â Â Â Â Â Â Â System.out.println("Length of Longest Increasing Subsequence is " + LongestIncreasingSubsequenceLength(A, n)); 
Â Â Â Â } 
} 
/* This code is contributed by Devesh Agrawal*/

```

## Python3

```

# Python program to find 
# length of longest 
# increasing subsequence 
# in O(n Log n) time 

# Binary search (note 
# boundaries in the caller) 
# A[] is ceilIndex 
# in the caller 
def CeilIndex(A, l, r, key): 

Â Â Â Â while (r - l > 1): 

Â Â Â Â Â Â Â Â m = l + (r - l)//2
Â Â Â Â Â Â Â Â if (A[m] >= key): 
Â Â Â Â Â Â Â Â Â Â Â Â r = m 
Â Â Â Â Â Â Â Â else: 
Â Â Â Â Â Â Â Â Â Â Â Â l = m 
Â Â Â Â return r 

def LongestIncreasingSubsequenceLength(A, size): 

Â Â Â Â # Add boundary case, 
Â Â Â Â # when array size is one 

Â Â Â Â tailTable = [0 for i in range(size + 1)] 
Â Â Â Â len = 0 # always points empty slot 

Â Â Â Â tailTable[0] = A[0] 
Â Â Â Â len = 1
Â Â Â Â for i in range(1, size): 

Â Â Â Â Â Â Â Â if (A[i] < tailTable[0]): 

Â Â Â Â Â Â Â Â Â Â Â Â # new smallest value 
Â Â Â Â Â Â Â Â Â Â Â Â tailTable[0] = A[i] 

Â Â Â Â Â Â Â Â elif (A[i] > tailTable[len-1]): 

Â Â Â Â Â Â Â Â Â Â Â Â # A[i] wants to extend 
Â Â Â Â Â Â Â Â Â Â Â Â # largest subsequence 
Â Â Â Â Â Â Â Â Â Â Â Â tailTable[len] = A[i] 
Â Â Â Â Â Â Â Â Â Â Â Â len+= 1

Â Â Â Â Â Â Â Â else: 
Â Â Â Â Â Â Â Â Â Â Â Â # A[i] wants to be current 
Â Â Â Â Â Â Â Â Â Â Â Â # end candidate of an existing 
Â Â Â Â Â Â Â Â Â Â Â Â # subsequence. It will replace 
Â Â Â Â Â Â Â Â Â Â Â Â # ceil value in tailTable 
Â Â Â Â Â Â Â Â Â Â Â Â tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] 

Â Â Â Â return len

# Driver program to 
# test above function 

A = [ 2, 5, 3, 7, 11, 8, 10, 13, 6 ] 
n = len(A) 

print("Length of Longest Increasing Subsequence is ", 
Â Â Â Â Â Â Â LongestIncreasingSubsequenceLength(A, n)) 

# This code is contributed 
# by Anant Agarwal. 

```

## C# 

```

// C# program to find length of longest 
// increasing subsequence in O(n Log n) 
// time 
using System; 

class GFG { 

Â Â Â Â // Binary search (note boundaries 
Â Â Â Â // in the caller) A[] is ceilIndex 
Â Â Â Â // in the caller 
Â Â Â Â static int CeilIndex(int[] A, int l, 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â int r, int key) 
Â Â Â Â { 
Â Â Â Â Â Â Â Â while (r - l > 1) { 
Â Â Â Â Â Â Â Â Â Â Â Â int m = l + (r - l) / 2; 

Â Â Â Â Â Â Â Â Â Â Â Â if (A[m] >= key) 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â r = m; 
Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â l = m; 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â return r; 
Â Â Â Â } 

Â Â Â Â static int LongestIncreasingSubsequenceLength( 
Â Â Â Â Â Â Â Â int[] A, int size) 
Â Â Â Â { 

Â Â Â Â Â Â Â Â // Add boundary case, when array size 
Â Â Â Â Â Â Â Â // is one 

Â Â Â Â Â Â Â Â int[] tailTable = new int[size]; 
Â Â Â Â Â Â Â Â int len; // always points empty slot 

Â Â Â Â Â Â Â Â tailTable[0] = A[0]; 
Â Â Â Â Â Â Â Â len = 1; 
Â Â Â Â Â Â Â Â for (int i = 1; i < size; i++) { 
Â Â Â Â Â Â Â Â Â Â Â Â if (A[i] < tailTable[0]) 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // new smallest value 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tailTable[0] = A[i]; 

Â Â Â Â Â Â Â Â Â Â Â Â else if (A[i] > tailTable[len - 1]) 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // A[i] wants to extend largest 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // subsequence 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tailTable[len++] = A[i]; 

Â Â Â Â Â Â Â Â Â Â Â Â else

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // A[i] wants to be current end 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // candidate of an existing 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // subsequence. It will replace 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // ceil value in tailTable 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tailTable[CeilIndex(tailTable, -1, 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â len - 1, A[i])] 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = A[i]; 
Â Â Â Â Â Â Â Â } 

Â Â Â Â Â Â Â Â return len; 
Â Â Â Â } 

Â Â Â Â // Driver program to test above function 
Â Â Â Â public static void Main() 
Â Â Â Â { 
Â Â Â Â Â Â Â Â int[] A = { 2, 5, 3, 7, 11, 8, 10, 13, 6 }; 
Â Â Â Â Â Â Â Â int n = A.Length; 
Â Â Â Â Â Â Â Â Console.Write("Length of Longest "
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â + "Increasing Subsequence is " + LongestIncreasingSubsequenceLength(A, n)); 
Â Â Â Â } 
} 

// This code is contributed by nitin mittal. 

```

## PHP

```

<?php 
// PHP program to find 
// length of longest 
// increasing subsequence 
// in O(n Log n) time 

// Binary search (note 
// boundaries in the caller) 
// A[] is ceilIndex 
// in the caller 
function CeilIndex($A, $l, $r, $key) 
{ 
Â Â Â Â while ($r - $l > 1) 
Â Â Â Â { 
Â Â Â Â Â Â Â Â $m = (int)($l + ($r - $l)/2); 
Â Â Â Â Â Â Â Â if ($A[$m] >= $key) 
Â Â Â Â Â Â Â Â Â Â Â Â $r = $m; 
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â $l = $m; 
Â Â Â Â } 
Â Â Â Â return $r; 
} 

function LongestIncreasingSubsequenceLength($A, $size) 
{ 
Â Â Â Â // Add boundary case, 
Â Â Â Â // when array size is one 

Â Â Â Â $tailTable = array_fill(0, ($size + 1), 0); 
Â Â Â Â $len = 0; // always points empty slot 

Â Â Â Â $tailTable[0] = $A[0]; 
Â Â Â Â $len = 1; 
Â Â Â Â for($i = 1; $i < $size; $i++) 
Â Â Â Â { 

Â Â Â Â Â Â Â Â if ($A[$i] < $tailTable[0]) 
Â Â Â Â Â Â Â Â Â Â Â Â // new smallest value 
Â Â Â Â Â Â Â Â Â Â Â Â $tailTable[0] = $A[$i]; 

Â Â Â Â Â Â Â Â else if ($A[$i] > $tailTable[$len-1]) 
Â Â Â Â Â Â Â Â { 
Â Â Â Â Â Â Â Â Â Â Â Â // A[i] wants to extend 
Â Â Â Â Â Â Â Â Â Â Â Â // largest subsequence 
Â Â Â Â Â Â Â Â Â Â Â Â $tailTable[$len] = $A[$i]; 
Â Â Â Â Â Â Â Â Â Â Â Â $len++; 
Â Â Â Â Â Â Â Â } 
Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â // A[i] wants to be current 
Â Â Â Â Â Â Â Â Â Â Â Â // end candidate of an existing 
Â Â Â Â Â Â Â Â Â Â Â Â // subsequence. It will replace 
Â Â Â Â Â Â Â Â Â Â Â Â // ceil value in tailTable 
Â Â Â Â Â Â Â Â Â Â Â Â $tailTable[CeilIndex($tailTable, -1, $len-1, $A[$i])] = $A[$i]; 

Â Â Â Â } 
Â Â Â Â return $len; 
} 

// Driver program to 
// test above function 
$A = array( 2, 5, 3, 7, 11, 8, 10, 13, 6 ); 
$n = count($A); 

print("Length of Longest Increasing Subsequence is ". 
Â Â Â Â Â Â Â Â LongestIncreasingSubsequenceLength($A, $n)); 

// This code is contributed by chandan_jnu 
?> 

```

**è¾“å‡º**ï¼š

```
Length of Longest Increasing Subsequence is 6
```

**å¤æ‚åº¦**ï¼š

å¾ªç¯è¿è¡Œ N ä¸ªå…ƒç´ ã€‚ åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼ˆä»€ä¹ˆæ˜¯æœ€åæƒ…å†µçš„è¾“å…¥ï¼Ÿï¼‰ï¼Œæˆ‘ä»¬æœ€ç»ˆå¯èƒ½ä¼šä½¿ç”¨äºŒåˆ†æœç´¢ï¼ˆlog *i* ï¼‰æ¥æŸ¥è¯¢è®¸å¤š A [i]çš„ ceil å€¼ã€‚

å› æ­¤ï¼ŒTï¼ˆnï¼‰< Oï¼ˆlog Nï¼ï¼‰= Oï¼ˆN log Nï¼‰ã€‚ åˆ†æä»¥ç¡®ä¿ä¸Šé™å’Œä¸‹é™ä¹Ÿæ˜¯ Oï¼ˆN log Nï¼‰ã€‚ å¤æ‚åº¦ä¸º THETAï¼ˆN log Nï¼‰ã€‚

**ç»ƒä¹ **ï¼š

1\. [è®¾è®¡ä¸€ç§ç®—æ³•ï¼Œä»¥æ„é€ æœ€é•¿çš„é€’å¢åˆ—è¡¨](https://www.geeksforgeeks.org/construction-of-longest-monotonically-increasing-subsequence-n-log-n/)ã€‚ å¦å¤–ï¼Œä½¿ç”¨ DAG å¯¹è§£å†³æ–¹æ¡ˆè¿›è¡Œå»ºæ¨¡ã€‚

2.è®¾è®¡ä¸€ç§ç®—æ³•ï¼Œä»¥æ„é€ **æ‰€æœ‰**çš„åˆ—è¡¨ï¼Œè¿™äº›åˆ—è¡¨å…·æœ‰ç›¸åŒçš„æœ€é•¿å¤§å°ã€‚

3.ä¸Šè¿°ç®—æ³•æ˜¯*åœ¨çº¿*ç®—æ³•å—ï¼Ÿ

4.è®¾è®¡ä¸€ç§ç®—æ³•æ¥æ„é€ æœ€é•¿çš„*é€’å‡*åˆ—è¡¨ã€‚

 **åœ¨ C++  ä¸­ä½¿ç”¨ [lower_boundï¼ˆï¼‰çš„æ›¿ä»£å®ç°ï¼š](https://www.geeksforgeeks.org/lower_bound-in-cpp/)**

```

#include<bits/stdc++.h> 
using namespace std;Â  

int LongestIncreasingSubsequenceLength(std::vector<int>& v)Â  
{Â  
Â Â Â Â if (v.size() == 0)Â  
Â Â Â Â Â Â Â Â return 0;Â  

Â Â Â Â std::vector<int> tail(v.size(), 0);Â  
Â Â Â Â int length = 1; // always points empty slot in tailÂ  

Â Â Â Â tail[0] = v[0];Â  

Â Â Â Â for (int i = 1; i < v.size(); i++) {Â  

Â Â Â Â Â Â Â Â Â Â Â Â // Do binary search for the element inÂ  
Â Â Â Â Â Â Â Â Â Â Â Â // the range from begin to begin + length 
Â Â Â Â Â Â Â Â auto b = tail.begin(), e = tail.begin() + length; 
Â Â Â Â Â Â Â Â auto it = lower_bound(b, e, v[i]);Â  

Â Â Â Â Â Â Â Â // If not present change the tail element to v[i]Â  
Â Â Â Â Â Â Â Â if (it == tail.begin() + length) 
Â Â Â Â Â Â Â Â tail[length++] = v[i];Â  
Â Â Â Â Â Â Â Â elseÂ Â Â 
Â Â Â Â Â Â Â Â *it = v[i];Â  
Â Â Â Â }Â  

Â Â Â Â return length;Â  
}Â  

int main()Â  
{Â  
Â Â Â Â std::vector<int> v{ 2, 5, 3, 7, 11, 8, 10, 13, 6 };Â  
Â Â Â Â std::cout << "Length of Longest Increasing Subsequence is "
Â Â Â Â Â Â Â Â Â Â Â Â << LongestIncreasingSubsequenceLength(v);Â  
Â Â Â Â return 0;Â  
}Â  

```

è¾“å‡ºï¼š

```
Length of Longest Increasing Subsequence is 6

```

â€” [Venki](http://www.linkedin.com/in/ramanawithu) ã€‚ å¦‚æœå‘ç°ä»»ä½•ä¸æ­£ç¡®çš„åœ°æ–¹ï¼Œæˆ–è€…æƒ³åˆ†äº«æœ‰å…³ä¸Šè¿°ä¸»é¢˜çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å†™è¯„è®ºã€‚

